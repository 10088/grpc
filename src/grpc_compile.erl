-module(grpc_compile).

-compile(export_all).

-export([file/2]).

%%% ============================================================================
%%% Exported functions
%%% ============================================================================

file(Filename, Options) ->
    RootName = filename:rootname(Filename),
    ok = gpb_compile:file(Filename, [maps | Options ++ [{i, "."}]]),
    CompiledPB = RootName ++ ".erl",
    GpbInludeDir = filename:join(code:lib_dir(gpb), "include"),
    {ok, Module, Compiled} = compile:file(CompiledPB, 
                                          [binary, {i, GpbInludeDir}]),
    {module, _} = code:load_binary(Module, CompiledPB, Compiled),
    ModuleName = filename:basename(RootName) ++ "_server",
    Header = print_header(ModuleName),
    Exports = print_exports(Module),
    Messages = print_messages(Module),
    Decoder = print_decoder(Module),
    Services = print_services(Module),
    ok = file:write_file(ModuleName ++ ".erl", [Header, Exports,
                                                Messages, Decoder,
                                                Services]).

%%% ============================================================================
%%% Internal functions
%%% ============================================================================

print_header(ModuleName) ->
    ["-module(", string_to_atom(ModuleName), ").\n\n"
     "%% this file was generated by grpc\n\n"].

print_exports(Module) ->
    RPCs = lists:flatten([begin
                              {_, Rs} = Module:get_service_def(S),
                              Rs
                          end || S <- Module:get_service_names()]),
    to_io_list(["-export([",
                separate(["decoder/0"] ++
                          [[Name, "/3"]|| #{name := Name} <- RPCs], ",\n         "),
                "]).\n\n"]).

 
print_messages(Module) -> 
    to_io_list([print_message(M) || M <- Module:get_msg_defs()]).

print_decoder(Module) ->
    to_io_list(["-spec decoder() -> module().\n",
                "%% The module (generated by gpb) used to encode and decode protobuf\n"
                "%% messages.\n",
                "decoder() -> ", Module, ".\n\n"]).

print_services(Module) ->
    to_io_list([print_service(Module:get_service_def(S)) 
                || S <- Module:get_service_names()]).

print_service_exports({_, RPCs}) ->
    [[Name, "/3"]|| #{name := Name} <- RPCs].

print_service({{service, Name}, RPCs}) ->
    ["%% RPCs for service ", Name, "\n\n",
     print_rpcs(RPCs)].

print_rpcs(RPCs) ->
    [print_rpc(R) || R <- RPCs].

print_rpc(#{input_stream := InStream, output_stream := OutStream} = Rpc) ->
    case {InStream, OutStream} of 
        {false, false} ->
            print_unary_rpc(Rpc);
        {false, true} -> 
            print_server_to_client_streaming_rpc(Rpc);
        {true, false} ->
            print_client_to_server_streaming_rpc(Rpc);
        {true, true} ->
            print_bidirectional_streaming_rpc(Rpc)
    end.
 
print_unary_rpc(#{name := Name,  
                  output := Output} = Rpc) ->
    [print_spec_call(Rpc),
     "    {", Output, "(), grpc:stream()} | grpc:error_response().\n",
     "%% This is a unary RPC\n",
     Name, "(_Message, Stream, _State) ->\n",
     "    {#{}, Stream}.\n\n"].

print_server_to_client_streaming_rpc(#{name := Name, 
                                       output := Output} = Rpc) ->
    [print_spec_call(Rpc),
     "    {[", Output, "()], grpc:stream()} | grpc:error_response().\n",
     "%% This is a server-to-client streaming RPC\n",
     Name, "(_Message, Stream, _State) ->\n",
     "    {[#{}], Stream}.\n\n"].

print_client_to_server_streaming_rpc(#{name := Name, 
                                       input := Input, 
                                       output := Output}) ->
    ["-spec ", Name, 
     "(Message::", Input, "() | eof, Stream::grpc:stream(), State::any()) ->\n",
     "    {continue, grpc:stream(), any()} |\n",
     "    {", Output, "(), grpc:stream()} |\n",
     "    grpc:error_response().\n",
     "%% This is a client-to-server streaming RPC. After the client has sent the last message\n",
     "%% this function will be called a final time with 'eof' as the first argument. This last\n",
     "%% invocation must return the response message.\n",
     Name, "(_Message, Stream, State) ->\n",
     "    {continue, Stream, State}.\n\n"].

print_bidirectional_streaming_rpc(#{name := Name, 
                                    input := Input, 
                                    output := Output}) ->
    ["-spec ", Name, 
     "(Message::", Input, "() | eof, Stream::grpc:stream(), State::any()) ->\n",
     "    {[", Output, "()], grpc:stream(), any()} |\n",
     "    {[", Output, "()], grpc:stream()} |\n",
     "    grpc:error_response().\n",
     "%% This is a bidirectional streaming RPC. If the client terminates the stream\n",
     "%% this function will be called a final time with 'eof' as the first argument.\n", 
     Name, "(_Message, Stream, State) ->\n",
     "    {[], Stream, State}.\n\n"].

print_spec_call(#{name := Name, input := Input}) ->
    ["-spec ", Name, 
     "(Message::", Input, "(), Stream::grpc:stream(), State::any()) ->\n"].

print_message({{msg, Name}, Fields}) -> 
    ["-type ", Name, "() ::\n    #{", print_fields(Fields), "}.\n\n"];
print_message({{enum, Name}, Options}) -> 
    ["-type ", Name, "() ::\n    ", print_options(Options), ".\n\n"].

print_fields(Fields) -> 
    separate([print_field(F) || F <- Fields], ",\n      ").

print_options(Options) -> 
    separate([V || {V, _} <- Options], " |\n    ").

print_field(#{name := Name, type := Type, occurrence := Occurrence}) ->
    [Name, 
     case {Occurrence, Type} of 
         {optional, _} -> " => ";
         {mandatory, _} -> " := ";
         %% Maps are marked as 'repeated' by gpb, but in fact they 
         %% have 1 value (a single map, not a list).
         {repeated, {map, _, _}}  -> " => ";
         {repeated, _}  -> " => ["
     end, 
     print_type(Type),
     case {Occurrence, Type} of 
         {repeated, {map, _, _}}  -> "";
         {repeated, _}  -> "]";
         _ -> ""
     end];
print_field(#{name := Name, fields := Alternatives}) ->
    [Name, " =>\n          ",
     separate([print_alternative(F) || F <- Alternatives], " |\n          ")].

print_alternative(#{name := Name, type := Type}) ->
    ["{", Name, ", ", print_type(Type), "}"].

print_type(int32) -> "integer()";
print_type(int64) -> "integer()";
print_type(uint32) -> "integer()";
print_type(uint64) -> "integer()";
print_type(sint32) -> "integer()";
print_type(sint64) -> "integer()";
print_type(fixed32) -> "integer()";
print_type(fixed64) -> "integer()";
print_type(sfixed32) -> "integer()";
print_type(sfixed64) -> "integer()";
print_type(string) -> "string()";
print_type(bool) -> "boolean()";
print_type(bytes) -> "binary()";
print_type(double) -> "pb_float()";
print_type(float) -> "pb_float()";
print_type({enum, Enum}) -> [Enum, "()"];
print_type({map, KeyType, ValueType}) -> 
    ["#{", print_type(KeyType), " => ", print_type(ValueType), "}"];
print_type({msg, MsgName}) -> [MsgName, "()"].

separate([], _) ->
    [];
separate(L, With) ->
    [Last | Rest] = lists:reverse(L),
    separate(Rest, With, [Last]).

separate([], _, Acc) ->
    Acc;
separate([I | T], With, Acc) ->
    separate(T, With, [I, With | Acc]).


to_io_list(L) ->
    print2(lists:flatten(L)).

print2(L) ->
    [lists:flatten([print3(C) || C <- L])].

print3(C) when is_atom(C) ->
    io_lib:format("~p", [C]);
print3(C) ->
    C.

string_to_atom(S) when is_list(S) ->
    io_lib:format("~p", [list_to_atom(S)]).

